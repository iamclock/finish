Как и на практике речь пойдёт о алгоритме шифрования, который в своей работе использует автомат с таблицей переходов и множеством состояний (его формула, показать картинку) для генерации ключевой последовательности, с помощью которой потом происходит шифрование текста, единственное отличие - раньше ключом было число - количество обращений к (генератору случайных чисел ляпаса) переменной X с целью получения наиболее непредсказуемого случайного значения, но т.к. это была особенность имеющегося у меня компилятора, такой подход был временной мерой, теперь, по задумке, ключом является тоже число, но использоваться оно будет, как начальное состояние автомата для первого его вызова, генератору на вход приходит начальное состояние и количество бит требующихся на выходе у ключевой последовательности. Но поскольку таблица переходов заполнена так, что в ней возможны зацикливания, то нужно придумать способ переключения, дабы миновать зацикливание. Проблемы имеются две: в какой момент проводить переключения и как совершать переключения.
В первом случае имеются несколько решений или предложений:
	1. Перед зацикливанием. Заранее посчитать период и при подходе к повторению производить переключение.
	2. Маркеры. В криптограмме ставятся метки, когда произошло переключение при шифровании, тогда во время расшифрования при встрече этой метки произвести переключение и продолжить расшифровывающую деятельность. Тогда можно будет настроить генератор на случайное переключение.
	3. Такты. Обе стороны вместе с ключом передают количество тактов для переключения и тогда после этого количества обращений (или менее, потому что автомат может начать зацикливание раньше) к автомату генератор будет сам изменять текущее состояние
Во втором случае переключением может послужить формула, а состояние его сидом:
	1. Линейный конгруэнтный метод или инверсный конгруэнтный метод.
	2. Fortuna
	3. Вычисление полинома. Вместе с ключом передаются коэффициенты полинома(тогда это не отличается от линейного конгруэнтного метода) или степени полинома, а переменные иксы это начальное состояние при ключевой последовательности
	4. Хэш-функции. подсчёт односторонней функции и взятие значения от неё (несколько бит) возможны коллизии


		Инверсный конгруэнтный метод.




		Fortuna.
Был замечен при изучении алгоритма Ярроу. Состоит из 3ёх частей:
	1. Генератор, инициализируемый начальным числом (англ. seed) фиксированной длины и выдающий произвольное количество псевдослучайных бит.
	2. Аккумулятор энтропии, собирающий случайные данные из различных источников и изменяющий начальное число генератора всякий раз, когда накоплено достаточное число энтропии.
	3. Система управления файлом начального числа, обеспечивающая возможность генерации псевдослучайных чисел непосредственно после перезагрузки компьютера.

